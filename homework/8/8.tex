\documentclass[boxes]{homework}

% This is a slightly-more-than-minimal document that uses the homework class.
% See the README at http://git.io/vZWL0 for complete documentation.

\name{傅申 PB20000051}        % Replace (Your Name) with your name.
\term{2022 秋}     % Replace (Current Term) with the current term.
\course{算法基础}    % Replace (Course Name) with the course name.
\hwnum{8}          % Replace (Number) with the number of the homework.
\hwname{作业}
\problemname{}
\solutionname{解:}

% Load any other packages you need here.
\usepackage[
    a4paper,
    top = 2.54cm,
    bottom = 2.54cm,
    left = 1.91cm,
    right = 1.91cm,
    includeheadfoot
]{geometry}
\fancyfootoffset{0pt} % make fancyhdr work properly
\usepackage{ctex}
\usepackage{tikz}
\tikzset{
    every node/.style={circle,draw,inner sep=0pt,minimum size=1.5em},
    null/.style={draw=none},
    level 1/.style={sibling distance=14em,level distance=3em},
    level 2/.style={sibling distance=8em,level distance=3em},
    level 3/.style={sibling distance=4em,level distance=3em},
    level 4/.style={sibling distance=3em,level distance=3em},
    level 5/.style={sibling distance=2em,level distance=3em},
}

\begin{document}
%%%% Problem 4.2-3 %%%%
\problemchap{4}
\problempart{2}
\problemnumber{3}
\begin{problem}
如何修改 Strassen 算法, 使之适应矩阵规模 $n$ 不是 2 的幂的情况? 证明: 算法的运行
时间为 $\Theta \left( n^{\lg 7}\right)$.
\end{problem}
\begin{solution}
    只需要在矩阵最后追加行和列, 用零填充, 拓展到 $2^{k}$ 的规模使用 Strassen 算
    法, 再将结果中多余的行和列去掉即可. 证明: 假设 $m = 2^{k}$ 是大于 $n$ 的最小
    的 2 的幂, 则算法的运行时间为 $\Theta \left( m^{\lg 7}\right)$, 而显然有
    $n \leqslant m < 2n$, 且
    \begin{equation}
        n^{\lg 7} \leqslant m^{\lg 7} < 7 \cdot n^{\lg 7}
    \end{equation}
    所以算法的运行时间为 $\Theta \left( n^{\lg 7}\right)$.
\end{solution}

%%%% Problem 30.1-1 %%%%
\problemchap{30}
\problempart{1}
\problemnumber{1}
\begin{problem}
运用等式~\ref{eq:30.1} 和~\ref{eq:30.2}, 把下列两个多项式相乘:
$A(x) = 7x^{3} - x^{2} + x - 10$ 和 $B(x) = 8x^{3} - 6x + 3$.
\begin{equation}
    \label{eq:30.1}
    C(x) = \sum_{j = 0}^{2n - 2} c_{j} x^{j} \tag{30.1}
\end{equation}
\begin{equation}
    \label{eq:30.2}
    c_{j} = \sum_{k = 0}^{j} a_{k} b_{j - k} \tag{30.2}
\end{equation}
\end{problem}
\begin{solution}
    如下:
    \begin{equation}
        \begin{aligned}
            C(x)
             & = A(x)B(x) = 56 x^{6} + (-8) x^{5} + (8 - 42) x^{4} +
            (-80 + 6 + 21) x^{3} + (-6 - 3) x^{2} + (60 + 3) x - 30       \\
             & = 56x^{6} - 8x^{5} - 34x^{4} - 53x^{3} - 9x^{2} + 63x - 30
        \end{aligned}
    \end{equation}
\end{solution}

%%%% Problem 30.1-2 %%%%
\begin{problem}
求一个次数界为 $n$ 的多项式 $A(x)$ 在某给定点 $x_{0}$ 的值存在另外一种方法: 把多
项式 $A(x)$ 除以多项式 $\left( x - x_{0}\right)$, 得到一个次数界为 $n - 1$ 的商
多项式 $q(x)$ 和预想 $r$, 满足 $A(x) = q(x) \left( x - x_{0}\right) + r$. 很明
显, $A \left( x_{0}\right) = r$. 请说明如何根据 $x_{0}$ 和 $A$ 的系数, 在
$\Theta(n)$ 的时间复杂度内计算出余项 $r$ 以及 $q(x)$ 的系数.
\end{problem}
\begin{solution}
    设 $A(x)$ 和 $q(x)$ 的系数分别为 $a_{0}, a_{2}, \cdots, a_{n}$ 和
    $q_{0}, q_{2}, \cdots, q_{n - 1}$. 可以从后向前计算, 依次有
    $q_{n - 1} = a_{n}$, $q_{n - i - 1} = a_{n - i} + x_{0}q_{n - i}$,
    $n \geqslant i \geqslant 1$, $r = a_{0} + x_{0}q_{0}$. 显然算法的时间复杂度
    为 $\Theta(n)$.
\end{solution}

%%%% Problem 30.2-2 %%%%
\problempart{2}
\problemnumber{2}
\begin{problem}
计算向量 (0, 1, 2, 3) 的 DFT\@.
\end{problem}
\begin{solution}
    写成多项式的形式: $A(x) = 3x^{3} + 2x^{2} + x$, 则
    \begin{equation}
        \begin{aligned}
            y_{0} & = A(1) = 6                &  &  & y_{1} & = A(\mathrm{i}) =
            -3i - 2 + i = -2 - 2 \mathrm{i}                                     \\
            y_{2} & = A(-1) = -3 + 2 - 1 = -2 &  &  & y_{3} & = A(- \mathrm{i})
            = 3 \mathrm{i} - 2 - \mathrm{i} = 2 \mathrm{i} - 2
        \end{aligned}
    \end{equation}
    则 (0, 1, 2, 3) 的 DFT 为 $(6, -2 - 2 \mathrm{i}, -2, 2 \mathrm{i} - 2)$.
\end{solution}

%%%% Problem 30.2-5 %%%%
\problemnumber{5}
\begin{problem}
请把 FFT 推广到 $n$ 是 3 的幂的情形, 写出运行时间的递归式并求解.
\end{problem}
\begin{solution}
    首先有
    \begin{equation}
        {\left( w_{n}^{k + n / 3}\right)}^{3} = w_{n}^{3k + n} = w_{n}^{3k} =
        w_{n / 3}^{k}
    \end{equation}
    然后定义三个新的次数界为 $n / 3$ 的多项式 $A^{[0]}(x)$, $A^{[1]}(x)$ 和
    $A^{[2]}(x)$:
    \begin{equation}
        \begin{aligned}
            A^{[0]}(x) & = a_{0} + a_{3} x + a_{6} x^{2} + \cdots +
            a_{n - 3} x^{n / 3 - 1}                                 \\
            A^{[1]}(x) & = a_{1} + a_{4} x + a_{7} x^{2} + \cdots +
            a_{n - 2} x^{n / 3 - 1}                                 \\
            A^{[2]}(x) & = a_{2} + a_{5} x + a_{8} x^{2} + \cdots +
            a_{n - 1} x^{n / 3 - 1}
        \end{aligned}
    \end{equation}
    则有
    \begin{equation}
        A(x) = A^{[0]} \left( x^{3}\right) + xA^{[1]} \left( x^{3}\right) +
        x^{2}A^{[2]} \left( x^{3}\right)
    \end{equation}
    问题就转换为了求次数界为 $n / 3$ 的多项式 $A^{[0]}(x)$, $A^{[1]}(x)$ 和
    $A^{[2]}(x)$ 在 ${\left( w_{n}^{0}\right)}^{3},
        {\left( w_{n}^{1}\right)}^{3}, \cdots,
        {\left( w_{n}^{n / 3 - 1}\right)}^{3}$ 上的取值. 推广后的 FFT 如下
    \begin{algo}
        \caption{3-POWER-FFT\.($a$)}

        $n = a.length$\;
        \If{$n = 1$}{
            \Return{$a$}\;
        }
        $w_{n} = \mathrm{e}^{2\pi \mathrm{i} / n}$\;
        $w = 1$\;
        $a^{[0]} = \left( a_{0}, a_{3}, \ldots, a_{n - 3} \right)$\;
        $a^{[1]} = \left( a_{1}, a_{4}, \ldots, a_{n - 2} \right)$\;
        $a^{[2]} = \left( a_{2}, a_{5}, \ldots, a_{n - 1} \right)$\;
        $y^{[0]} = \operatorname{3-POWER-FFT} \left( a^{[0]}\right)$\;
        $y^{[1]} = \operatorname{3-POWER-FFT} \left( a^{[1]}\right)$\;
        $y^{[2]} = \operatorname{3-POWER-FFT} \left( a^{[2]}\right)$\;
        \For{$k = 0$ \textbf{to} $n / 3 - 1$}{
        $y_{k} = y^{[0]}_{k} + w y^{[1]}_{k} + w^{2} y^{[2]}_{k}$\;
        $y_{k + n / 3} = y^{[0]}_{k} + w y^{[1]}_{k}
            \mathrm{e}^{2\mathrm{i}\pi / 3} + w^{2} y^{[2]}_{k}
            \mathrm{e}^{4\mathrm{i}\pi / 3}$\;
        $y_{k + 2n / 3} = y^{[0]}_{k} + w y^{[1]}_{k}
            \mathrm{e}^{4\mathrm{i}\pi / 3} + w^{2} y^{[2]}_{k}
            \mathrm{e}^{2\mathrm{i}\pi / 3}$\;
        $w = w w_{n}$\;
        }
        \Return{$y$}\;
    \end{algo}
    运行时间的递归式为
    \begin{equation}
        T(n) = 3 T \left( \frac{ n }{ 3 }\right) + \Theta(n) = \Theta(n \lg n)
    \end{equation}
\end{solution}

%%%% Problem 30.3-1 %%%%
\problempart{3}
\problemnumber{1}
\begin{problem}
请说明如何用 {\sc Iterative-FFT} 计算输入向量 $(0, 2, 3, -1, 4, 5, 7, 9)$ 的
DFT\@.
\end{problem}
\begin{solution}
    首先 {\sc Bit-Reverse-Copy} 后得到 $(0, 4, 3, 7, 2, 5, -1, 9)$, 然后第一轮
    循环得到 $(4, -4, 10, -4, 7, -3, 8,$ $-10)$, 第二轮循环得到 $(14, -4 -
        4 \mathrm{i}, -6, -4 + 4 \mathrm{i}, 15, -3 - 10 \mathrm{i}, -1,
        -3 + 10\mathrm{i})$, 最后一轮循环得到
    \begin{equation}
        y =
        \begin{pmatrix}
            29                                              \\
            \frac{ 7 \sqrt{2} }{ 2 } - 4 - \left(4 +
            \frac{ 13 \sqrt{2} }{ 2 }\right) \mathrm{i}     \\
            -6 - \mathrm{i}                                 \\
            - 4 - \frac{ 7 \sqrt{2} }{ 2 } + \left(4 -
            \frac{ 13 \sqrt{2} }{ 2 }\right) \mathrm{i}     \\
            -1                                              \\
            - 4 - \frac{ 7 \sqrt{2} }{ 2 } + \left(
            \frac{ 13 \sqrt{2} }{ 2 } - 4\right) \mathrm{i} \\
            -6 + \mathrm{i}                                 \\
            \frac{ 7 \sqrt{2} }{ 2 } - 4 + \left(4 +
            \frac{ 13 \sqrt{2} }{ 2 }\right) \mathrm{i}     \\
        \end{pmatrix}
    \end{equation}
\end{solution}

%%%% Problem 30.3-2 %%%%
\problemnumber{2}
\begin{problem}
请说明如何实现一个 FFT 算法, 注意把位逆序置换放在计算的最后而不是开始. (提示: 考
虑逆 DFT)
\end{problem}
\begin{solution}
    首先将 {\sc Iterative-FFT} 中的 $w_{n}$ 修改为 $w_{n}^{-1}$, 并将计算结果的
    每个元素都除以 $n$, 就得到了求逆 DFT 的算法. 再将该算法逆序执行, 即先逆序执
    行外循环 ($s = \lg n \to 1$), 并将最内部的循环体作修改, 再将计算结果的每个元
    素都乘以 $n$, 最后进行位逆序置换, 就得到了 DFT\@. 算法如下:
    \begin{algo}
        \caption{ANOTHER-ITERATIVE-FFT\.($a$)}
        $n = a.length$\;
        \For{$s = \lg n$ \textbf{downto} $1$} {
        $m = 2^{s}$\;
        $w_{m}^{-1} = \mathrm{e}^{- 2\pi \mathrm{i} / m}$
        \For{$k = 0$ \textbf{to} $n - 1$ \textbf{by} $m$} {
            $w = 1$\;
            \For{$j = 0$ \textbf{to} $m / 2 - 1$} {
                $t = a[k + j] + a[k + j + m / 2]$\;
                $u = a[k + j] - a[k + j + m / 2]$\;
                $a[k + j] = t / 2$\;
                $a[k + j + m / 2] = w u / 2$\;
                $w = w w_{m}^{-1}$\;
            }
        }
        \For{$k = 0$ \textbf{to} $n - 1$} {
            $a[k] = na[k]$\;
        }
        BIT-REVERSE-COPY\.($a$, $A$)\;
        \Return{A}
        }
    \end{algo}
\end{solution}

%%%% Problem 12.1-5 %%%%
\problemchap{12}
\problempart{1}
\begin{problem}
因为在基于比较的排序模型中, 完成 $n$ 个元素的排序, 其最坏情况下需要
$\Omega(n\lg n)$ 时间. 试证明: 任何基于比较的算法从 $n$ 个元素的任意序列中构造
一棵二叉搜索树, 其最坏情况下需要 $\Omega(n\lg n)$ 的时间.
\end{problem}
\begin{solution}
    假设存在一个基于比较的算法, 在最坏情况下, 其能在 $O(n \lg n)$ 的时间内构造一
    棵二叉搜索树, 那么对于任何输入序列, 我们先调用该算法构造二叉搜索树, 再中序遍
    历该二叉搜索树, 并将遍历到的结点的值依次存储到数组中, 就完成了一次基于比较的
    排序. 其中算法的执行时间为 $O(n\lg n)$, 而中序遍历的时间为 $\Theta(n)$, 合起
    来是 $O(n\lg n)$, 与基于比较的排序算法最坏情况下的运行时间矛盾, 故假设不成
    立.
\end{solution}

%%%% Extra Problem %%%%
\problemchap{Extra}
\problempart{1}
\problemnumber{1}
\begin{problem}
将 ``E A S Y Q U E S T I O N'' 作为键按顺序插入到一棵空的二叉搜索树中, 画出生成
的二叉搜索树. 构造这棵树需要多少次比较?
\end{problem}
\begin{solution}
    如下
    \begin{center}
        \begin{tikzpicture}
            \node{E}
            child { node {A}
                    child { node[null] {} edge from parent[draw=none] }
                    child { node {E} }
                }
            child { node {S}
                    child { node {Q}
                            child { node {I}
                                    child { node[null] {} edge from parent[draw=none] }
                                    child { node {O}
                                            child { node {N} }
                                            child { node[null] {} edge from parent[draw=none] }
                                        }
                                }
                            child { node {S} }
                        }
                    child { node {Y}
                            child { node {U}
                                    child { node {T} }
                                    child { node[null] {} edge from parent[draw=none] }
                                }
                            child { node[null] {} edge from parent[draw=none] }
                        }
                };
        \end{tikzpicture}
    \end{center}
    需要 $2 \times 1 + 3 \times 2 + 3 \times 3 + 2 \times 4 + 1 \times 5 = 30$
    次比较.
\end{solution}


\end{document}
